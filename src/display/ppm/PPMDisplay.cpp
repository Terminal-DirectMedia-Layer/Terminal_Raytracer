#include "display/ppm/PPMDisplay.hpp"

#include <fstream>
#include <format>

#include <algorithm>

namespace RayTracer
{
    PPMDisplay::PPMDisplay(std::size_t width, std::size_t height, const std::string &name) :
        _name(name),
        _size(static_cast<int>(width), static_cast<int>(height)),
        _framebuffer(width, height)
    {}

    PPMDisplay::~PPMDisplay()
    {
        std::ofstream ppmWriter;
        ppmWriter.exceptions(std::ofstream::failbit | std::ofstream::badbit);
        ppmWriter.open(std::format("{}.ppm", this->_name));

        ppmWriter << "P3" << std::endl
                  << "# Image '" << this->_name << "' generated by RayTracer" << std::endl
                  << this->_size.width() << " " << this->_size.height() << std::endl
                  << "255" << std::endl;

        this->_framebuffer.access([this, &ppmWriter](Color *framebufferPtr) {
            for (std::size_t i = 0;
                 i < static_cast<std::size_t>(this->_size.width() * this->_size.height());
                 i++) {
                Color color = framebufferPtr[i];

                ppmWriter << std::clamp(static_cast<std::size_t>(color.r * 255), 0ul, 255ul) << " "
                          << std::clamp(static_cast<std::size_t>(color.g * 255), 0ul, 255ul) << " "
                          << std::clamp(static_cast<std::size_t>(color.b * 255), 0ul, 255ul) << std::endl;
            }
        });
    }

    void PPMDisplay::update()
    {
        // Nothing to do
    }

    void PPMDisplay::clear(Color color)
    {
        this->_framebuffer.access([this, color](Color *framebufferPtr) {
            std::fill(framebufferPtr, framebufferPtr + this->_size.width() * this->_size.height(), color);
        });
    }

    Rectangle2i PPMDisplay::getViewport() const
    {
        return this->_size;
    }

    Framebuffer & PPMDisplay::getFramebuffer()
    {
        return this->_framebuffer;
    }
};
